#!/usr/bin/env bash

set -eo pipefail

if [[ "${TAP_CI_ARGS_PUBLISH_NPM_PACKAGE_DEBUG:-false}" =~ (true|on|1) ]]; then
	echo "~~~ :hammer: Enabling debug mode"
	set -x
fi

# Echo to standard error
function log() {
	echo "$@" 1>&2
}

# Expand variable if it starts with $ sign
function expandVariable() {
	if [[ "${1::1}" == "\$" ]]; then
		local varName=${1:1}
		echo "${!varName}"
	else
		echo "${1}"
	fi
}

# Re-export variables passed into plugin as local variables
function collect_args() {
	local prefix="TAP_CI_ARGS_PUBLISH_NPM_PACKAGE_"
	local prefix_length="${#prefix}"

	while IFS='=' read -r name value; do
		if [[ $name == "$prefix"* ]]; then
			local new_var_name="${name:$prefix_length}"
			declare -rg "$new_var_name"="$(expandVariable "${value}")"
		fi
	done < <(env | sort)
}

collect_args

if [ ! -f package.json ]; then
	log "ERROR: No package.json file found."
	exit 1
fi

# Run `npm publish` in dry run mode.
dry_run="${DRY_RUN:-false}"

# Use remote version of package as base when incrementing version.
use_remote="${USE_REMOTE:-false}"

# Get new_version from environment or default to 'patch'
new_version="${NEW_VERSION:-patch}"

# Handle command line arguments for backward compatibility
# Function to display usage information
usage() {
	log "Usage: $0 [-n] [-r] [version]"
	log "  -n      Enable dry run mode"
	log "  -r      Use remote version as base version when incrementing"
	log "  version Version bump type (patch, minor, major, etc.)"
}

while getopts ":nr" opt; do
	case "${opt}" in
	n)
		dry_run=true
		;;
	r)
		use_remote=true
		;;
	\?)
		log "Invalid option: -$OPTARG"
		usage
		exit 2
		;;
	esac
done
shift $((OPTIND - 1))

# Command line arguments override environment variables
if [ $# -gt 0 ]; then
	new_version="$1"
fi
package_name="$(jq --raw-output .name package.json)"
remote_hash="$(npm view "${package_name}" dist.shasum 2>/dev/null || echo NOT_FOUND)"
local_hash="$(npm publish --dry-run --json 2>/dev/null | jq --raw-output '.. | objects | .shasum // empty')"
if [ "${local_hash}" = "${remote_hash}" ]; then
	log "Package \"${package_name}\" with shasum ${local_hash} is already published."
	exit 0
fi

remote_version="$(npm view "${package_name}" version 2>/dev/null || echo '')"
if [ -n "$remote_version" ] && $use_remote; then
	log "Using remote version \"${remote_version}\" as base."
	npm version "${remote_version}" 2>/dev/null || log "Warning - Unable to set local version to ${remote_version}"
fi

npm version "${new_version}" &>/dev/null

publish_cmd="npm publish"
if $dry_run; then
	publish_cmd+=" --dry-run"
fi

eval "${publish_cmd}"
